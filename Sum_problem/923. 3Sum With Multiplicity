# Given an integer array arr, and an integer target, 
# return the number of tuples i, j, k such that i < j < k and arr[i] + arr[j] + arr[k] == target.
# As the answer can be very large, return it modulo 109 + 7.

# Example 1:
# Input: arr = [1,1,2,2,3,3,4,4,5,5], target = 8
# Output: 20
# Explanation: 
# Enumerating by the values (arr[i], arr[j], arr[k]):
# (1, 2, 5) occurs 8 times;
# (1, 3, 4) occurs 8 times;
# (2, 2, 4) occurs 2 times;
# (2, 3, 3) occurs 2 times.

"""
start-end-pointer, but need to deal with the counting. Ordinary start-end-pointer will pass many possible combinatiions.
When find the target, it need to find the duplicate of start and end. If start==end, it is C(end-start+1)2. If not, we need to count 
starts and ends. So, it is count_of_starts*count_of_ends.
"""
def threeSumMulti(self, arr: List[int], target: int) -> int:
    arr.sort()
    ans=0
    n=len(arr)
    for i in range(n-2):
        start=i+1
        end=n-1
        while start<end:
            if arr[i]+arr[start]+arr[end]==target:
                if arr[start]==arr[end]:
                    ans+=(end-start+1)*(end-start)//2
                    break
                else:
                    cnt_start=1
                    cnt_end=1
                    while start+1<end and arr[start]==arr[start+1]:
                        cnt_start+=1
                        start+=1
                    while start<end-1 and arr[end]==arr[end-1]:
                        cnt_end+=1
                        end-=1                    
                    ans+=cnt_start*cnt_end
                    start+=1
                    end-=1
            elif arr[i]+arr[start]+arr[end]>target:
                end-=1
            else:
                start+=1
    return ans%(10**9+7)
